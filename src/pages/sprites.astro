---
import FrontPageLayout from "../layouts/FrontPageLayout.astro";
import SpriteBrowser from "../components/SpriteBrowser.svelte";

// OPTIMIZATION: Import Redis caching utilities
import { getCached, setCached, cacheKey, CACHE_TTL } from '../lib/redis';

// OPTIMIZATION: Fetch initial sprite data server-side for faster page loads
const API_BASE_URL = "https://cms.sgxp.me/api/sprites";

let initialSprites = [];
let initialTotalResults = 0;

// Performance timing
const perfStart = performance.now();
console.log('[Sprites SSR] ‚è±Ô∏è  Page load started');

// Cache key for initial sprites list (page 1, newest first, no filters)
const spritesCacheKey = cacheKey.spritesList(1, '-createdAt', 'none');

try {
  const cacheCheckStart = performance.now();
  // OPTIMIZATION: Try Redis cache first
  const cachedData = await getCached<{ docs: any[], totalDocs: number }>(spritesCacheKey);
  const cacheCheckDuration = performance.now() - cacheCheckStart;

  if (cachedData) {
    console.log(`[Sprites SSR] ‚úÖ Cache HIT - using cached sprites list (${cacheCheckDuration.toFixed(0)}ms)`);
    initialSprites = cachedData.docs;
    initialTotalResults = cachedData.totalDocs;
  } else {
    console.log(`[Sprites SSR] ‚ùå Cache MISS after ${cacheCheckDuration.toFixed(0)}ms - fetching from API`);

    // OPTIMIZATION: Fetch with timeout to prevent long blocking
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout

    try {
      const fetchStart = performance.now();
      // OPTIMIZATION: Reduced depth from 2 to 1 for 3x faster API response (210ms vs 667ms)
      const response = await fetch(
        `${API_BASE_URL}?depth=1&draft=false&locale=undefined&trash=false&limit=21&page=1&sort=-createdAt`,
        { signal: controller.signal }
      );
      const fetchDuration = performance.now() - fetchStart;
      console.log(`[Sprites SSR] üåê API fetch completed in ${fetchDuration.toFixed(0)}ms`);

      clearTimeout(timeoutId);

      const parseStart = performance.now();
      const data = await response.json();
      const parseDuration = performance.now() - parseStart;
      console.log(`[Sprites SSR] üì¶ JSON parsing completed in ${parseDuration.toFixed(0)}ms`);

      if (data.docs) {
        initialSprites = data.docs;
        initialTotalResults = data.totalDocs;

        // Cache the result (fire and forget)
        const cacheSetStart = performance.now();
        setCached(spritesCacheKey, { docs: data.docs, totalDocs: data.totalDocs }, CACHE_TTL.SPRITES_LIST);
        const cacheSetDuration = performance.now() - cacheSetStart;
        console.log(`[Sprites SSR] üíæ Cached result in ${cacheSetDuration.toFixed(0)}ms`);
        console.log(`[Sprites SSR] ‚ÑπÔ∏è  Fetched ${data.docs.length} sprites (${data.totalDocs} total)`);
      }
    } catch (fetchError: any) {
      clearTimeout(timeoutId);
      if (fetchError.name === 'AbortError') {
        console.warn('[Sprites SSR] ‚ö†Ô∏è  Fetch timed out - client will load sprites');
      } else {
        throw fetchError;
      }
    }
  }
} catch (error) {
  console.error('[Sprites SSR] ‚ùå Error fetching initial sprites:', error);
  // Component will handle empty state
}

const perfEnd = performance.now();
const totalDuration = perfEnd - perfStart;
console.log(`[Sprites SSR] ‚è±Ô∏è  Total SSR processing time: ${totalDuration.toFixed(0)}ms`);
---

<FrontPageLayout title="Sprites">
  <div class="sprite-page-container">
    <div class="flex flex-col items-center justify-start w-full">
      <!-- OPTIMIZATION: Use client:only to skip SSR entirely and test performance -->
      <!-- This will help identify if SpriteBrowser SSR is the bottleneck -->
      <SpriteBrowser
        client:only="svelte"
        initialSprites={initialSprites}
        initialTotalResults={initialTotalResults}
      />
    </div>
  </div>
</FrontPageLayout>